Singleton Desgin Pattern
========================
What is the Singleton Pattern?
-> The Singleton Design Pattern ensures that only one instance of a class is created and that the same instance is used everywhere in the application.
-> It also provides a global point of access to that instance.

-> Singleton object are the object which are instantiated only once for project. If we try to get the object then we get same object again and again.

Breaking Singleton Design Pattern
---------------------------------
There are three ways to break singleton design pattern
 1. Using Reflection API
 -> With the help of relfection api we can call private constructor as well and create multiple object by calling private constructor.
      solution
       we can do the soultion in two ways.
       a. using ENUM
       b. check the object in private constructor if the object exists then throw exception to terminate the execution.
 2. Using Deserialization
 -> when weserialze and deserialze the singleton object then singleton automatically got destroyed and provide us different object.
       solution:
       just implement readResolve() method
       public Object readResolve() {
       return ob;
       }
 3. Using cloning
 ->  when we clone then also we get different object.
      solution
       just override clone method and return the same instance.
       @Override
       public Object clone() throws CloneNotSupportedException {
       return samosa;
       }


| Use Case                     | Why Singleton?                                                       | Example                                          |
| ---------------------------- | -------------------------------------------------------------------- | ------------------------------------------------ |
| **Logger**                   | Only one logging instance should exist to write to a single log file | `Logger.getInstance().log("Some log")`           |
| **Database Connection Pool** | Avoid creating multiple heavy DB connections                         | `DBConnectionPool.getInstance().getConnection()` |
| **Configuration Settings**   | Load once and reuse throughout the app                               | `Config.getInstance().get("db.url")`             |
| **Cache**                    | Centralized in-memory data store                                     | `CacheManager.getInstance().put("key", "value")` |
| **Thread Pool Manager**      | Only one thread pool managing background tasks                       | `ThreadPool.getInstance().submit(task)`          |

Best Practices:
-> Use Enum Singleton (recommended in Java) to avoid reflection and serialization issues.
-> Avoid using Singleton just for convenience. Use it only when single instance is logically required.

Factory Desgin Pattern
======================
-> When there is superclass and multiple subclasses and we want to get object of subclasses based on input and requirement. 
   Then we create factory class which takes the responsibility of creating object of class based on input.

Advantages
 1. Focus on creating object for Interface rather than implementation.
 2. Loose coupling, more robust code
 3. Supports polymorphism
 4. Code reuse 

| Use Case                | Description                                                                           |
| ----------------------- | ------------------------------------------------------------------------------------- |
| **Shape Drawing App**   | User selects shape: circle, square, triangle — factory returns the appropriate object |
| **Document Readers**    | Open file with `.doc`, `.pdf`, `.txt` — factory returns appropriate reader class      |
| **Notification System** | Send SMS, Email, or Push notification — factory decides which notifier class to use   |
| **Database Connector**  | Based on configuration: MySQL, PostgreSQL, MongoDB — factory gives correct connector  |


Abstract Factory Design Pattern
===============================
-> the Abstract Factory Design Pattern is indeed similar to the Factory Pattern but goes one level higher by providing a factory of factories.
-> The Abstract Factory Pattern provides an interface for creating families of related or dependent objects without specifying their concrete classes.
-> “Factory of Factories” — because it creates a group of factories.

| Scenario         | Explanation                                                                                                  |
| ---------------- | ------------------------------------------------------------------------------------------------------------ |
| GUI Toolkit      | You have multiple themes (Windows, Mac, Linux). Each theme needs to create **Buttons**, **Checkboxes**, etc. |
| Abstract Factory | Create a `GUIFactory` that returns the correct Button and Checkbox factory depending on the OS.              |


 Builder Design Pattern
=======================
-> while creating object when object contain may attributes there are many problem exists :
 1. we have to pass many arguments to create object.
 2. some parameters might be optional
 3. factory class takes all responsibility for creating object . if the object is heavy then all complexity is the part of factory class. So in   builder pattern be create object step by step and finally return final object with desired values of attributes

| Use Case                               | Why Builder?                                  |
| -------------------------------------- | --------------------------------------------- |
| **Creating complex JavaBeans or DTOs** | Many optional fields, constructors get ugly   |
| **Creating an HTTP Request**           | Need to add headers, body, auth, query params |
| **Building SQL queries**               | Add select, where, group by, having, etc.     |
| **UI construction**                    | Build screens with optional components        |
| **Test Data Builders**                 | Build dummy/mock objects with flexible values |

Prototype Design Pattern
========================
 -> The concept is to copy an existing object rather than creating a new instance from scratch. because creating new object may be costly. This approach saves costly resources and time, especially when object creation is a heavy process.

| Use Case                 | Why Prototype?                                               |
| ------------------------ | ------------------------------------------------------------ |
| **Document Templates**   | Create new documents from a pre-defined structure            |
| **Game Development**     | Clone similar enemies/characters efficiently                 |
| **Graphic Editors**      | Clone shapes with properties like size, color                |
| **Data Caching**         | Clone objects from a cached prototype instead of re-fetching |
| **UI Prototyping Tools** | Duplicate UI components for reuse                            |

